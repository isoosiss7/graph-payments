import {Contract, constants, ethers} from 'ethers';
import {SigningKey, randomBytes, joinSignature} from 'ethers/lib/utils';

import {
  Allocation,
  encodeOutcome,
  AssetOutcomeShortHand,
  replaceAddressesAndBigNumberify,
  randomExternalDestination,
  VariablePart
} from '@statechannels/nitro-protocol';
import {expectRevert} from '@statechannels/devtools';
import Artifact from '../artifacts/contracts/AttestationApp.sol/AttestationApp.json';
import {AppData, fromJS, nullState} from '../src/utils/app-data';

const {AddressZero, HashZero} = constants;

// For some reason the JsonRPcProvider symbol is not the same as
// the ethers.providers.JsonRpcProvider. Need to resolve.
const testProvider = new ethers.providers.JsonRpcProvider(
  `http://localhost:${process.env.GANACHE_PORT}`
);

let AttestationApp: Contract;

const numParticipants = 2;
const addresses = {
  A: randomExternalDestination(),
  B: randomExternalDestination()
};

export async function setupContracts(
  provider: ethers.providers.JsonRpcProvider,
  {abi}: typeof import('../artifacts/contracts/AttestationApp.sol/AttestationApp.json'),
  address: string
): Promise<Contract> {
  return new Contract(address, abi, provider.getSigner(0));
}
const REQUEST_CID = '0xd902c18a1b3590a3d2a8ae4439db376764fda153ca077e339d0427bf776bd463';
const RESPONSE_CID = '0xd902c18a1b3590a3d2a8ae4439db376764fda153ca077e339d0427bf776bd463';
const CHAIN_ID = 4;
const SUBGRAPH_DEPLOYMENT_ID = HashZero;
const VERIFYING_CONTRACT = '0x1111111111111111111111111111111111122222';
const receipt = {
  requestCID: REQUEST_CID,
  responseCID: RESPONSE_CID,
  subgraphDeploymentID: SUBGRAPH_DEPLOYMENT_ID
};

const signer = new ethers.Wallet(
  '0x2143e68b42c8aefdf339ec3b59a576a3ccf42e47c7015a9e72b90de1a6cbeb1c'
);

// Generated by calling
// await signAttestation(
//   signer.privateKey,
//   REQUEST_CID,
//   RESPONSE_CID,
//   SUBGRAPH_DEPLOYMENT_ID,
//   CHAIN_ID,
//   VERIFYING_CONTRACT
// ));
const attestation =
  '0x3748764478fa9546b69f2547c1b9ee71ec2f3aad87b3aa9997f5fa4191b246ae05add0098735e97ecb2102d54670d66626dd2eba04b5571a787b29fe7b20d5671c';

beforeAll(async () => {
  await testProvider.ready;
  AttestationApp = await setupContracts(
    testProvider,
    Artifact,
    process.env.ATTESTATION_APP as string
  );
});

describe('state transitions', () => {
  const INVALID_QUERY_REQUEST = /RequestCID must be non-zero/i;
  const INVALID_ATTESTATION_SIGNATURE = /must be signed with the allocationId/i;
  const INVALID_TRANSITION_TO_QueryRequest = /RequestCID must be zero/i;
  const INVALID_TRANSITION_TO_AttestationProvided = /ResponseCID must be zero/i;
  const INVALID_TRANSITION_TO_QueryDeclined = /RequestCID must be non-zero/i;

  const baseState = {
    ...nullState,
    constants: {
      ...nullState.constants,
      verifyingContract: VERIFYING_CONTRACT,
      allocationId: signer.address,
      chainId: CHAIN_ID
    }
  };

  const noRequestCID = {
    ...baseState,
    variable: {
      ...baseState.variable
    }
  };

  const goodQuery = {
    ...baseState,
    variable: {
      ...baseState.variable,

      requestCID: receipt.requestCID,
      paymentAmount: 20,
      responseCID: HashZero,
      signature: HashZero
    }
  };

  const badSignature = {
    ...goodQuery,
    variable: {
      ...goodQuery.variable,
      responseCID: receipt.responseCID,
      signature: joinSignature(new SigningKey(randomBytes(64)).signDigest('0xabcdef'))
    }
  };

  const goodAttest = {
    ...goodQuery,
    variable: {
      ...goodQuery.variable,
      responseCID: receipt.responseCID,
      signature: attestation
    }
  };

  const badDecline = {
    ...goodQuery,
    variable: {
      ...goodQuery.variable
    }
  };

  const goodDecline = {
    ...badDecline,
    variable: {
      ...badDecline.variable,
      requestCID: HashZero
    }
  };

  it.each`
    fromAppData    | toAppData      | fromBalances      | toBalances        | turnNum | description
    ${goodQuery}   | ${goodAttest}  | ${{A: 100, B: 0}} | ${{A: 80, B: 20}} | ${3}    | ${'QueryRequest->GoodAttestation'}
    ${goodAttest}  | ${goodQuery}   | ${{A: 0, B: 0}}   | ${{A: 0, B: 0}}   | ${4}    | ${'GoodAttestation->QueryRequest'}
    ${goodQuery}   | ${goodDecline} | ${{A: 0, B: 0}}   | ${{A: 0, B: 0}}   | ${3}    | ${'QueryRequest->QueryDeclined'}
    ${goodDecline} | ${goodQuery}   | ${{A: 0, B: 0}}   | ${{A: 0, B: 0}}   | ${4}    | ${'QueryDeclined->QueryRequest'}
  `(
    `There is a valid transition for $description`,
    async ({
      fromAppData,
      toAppData,
      fromBalances,
      toBalances,
      turnNum
    }: {
      fromAppData: AppData;
      toAppData: AppData;
      fromBalances: AssetOutcomeShortHand;
      toBalances: AssetOutcomeShortHand;
      turnNum: number;
      description: string;
    }) => {
      fromBalances = replaceAddressesAndBigNumberify(
        fromBalances,
        addresses
      ) as AssetOutcomeShortHand;
      toBalances = replaceAddressesAndBigNumberify(toBalances, addresses) as AssetOutcomeShortHand;

      const fromAllocation: Allocation = [];
      const toAllocation: Allocation = [];

      Object.keys(fromBalances).forEach((key) =>
        fromAllocation.push({destination: key, amount: fromBalances[key] as string})
      );
      Object.keys(toBalances).forEach((key) =>
        toAllocation.push({destination: key, amount: toBalances[key] as string})
      );

      const fromOutcome = [{assetHolderAddress: AddressZero, allocationItems: fromAllocation}];
      const toOutcome = [{assetHolderAddress: AddressZero, allocationItems: toAllocation}];

      const [fromAppDataBytes, toAppDataBytes] = [fromJS(fromAppData), fromJS(toAppData)];

      const fromVariablePart: VariablePart = {
        outcome: encodeOutcome(fromOutcome),
        appData: fromAppDataBytes
      };
      const toVariablePart: VariablePart = {
        outcome: encodeOutcome(toOutcome),
        appData: toAppDataBytes
      };

      const isValidFromCall = await AttestationApp.validTransition(
        fromVariablePart,
        toVariablePart,
        turnNum,
        numParticipants
      );
      expect(isValidFromCall).toBe(true);
    }
  );

  // TODO: These should be refactored around the new AttestationApp design
  it.each`
    fromAppData    | toAppData       | turnNum | errorMsg
    ${baseState}   | ${noRequestCID} | ${2}    | ${INVALID_QUERY_REQUEST}
    ${goodQuery}   | ${badSignature} | ${3}    | ${INVALID_ATTESTATION_SIGNATURE}
    ${goodQuery}   | ${goodQuery}    | ${3}    | ${INVALID_TRANSITION_TO_QueryRequest}
    ${goodAttest}  | ${goodAttest}   | ${4}    | ${INVALID_TRANSITION_TO_AttestationProvided}
    ${goodDecline} | ${goodAttest}   | ${4}    | ${INVALID_TRANSITION_TO_AttestationProvided}
    ${goodAttest}  | ${goodDecline}  | ${4}    | ${INVALID_TRANSITION_TO_QueryDeclined}
    ${goodDecline} | ${goodDecline}  | ${4}    | ${INVALID_TRANSITION_TO_QueryDeclined}
  `(
    `Handles error: $errorMsg`,
    async ({
      fromAppData,
      toAppData,
      turnNum,
      errorMsg
    }: {
      isValid: boolean;
      fromAppData: AppData;
      toAppData: AppData;
      fromBalances: AssetOutcomeShortHand;
      toBalances: AssetOutcomeShortHand;
      turnNum: number;
      errorMsg: string;
    }) => {
      const outcome = [
        {
          assetHolderAddress: AddressZero,
          allocationItems: [
            {destination: addresses.A, amount: '0x0'},
            {destination: addresses.B, amount: '0x0'}
          ]
        }
      ];

      const [fromAppDataBytes, toAppDataBytes] = [fromJS(fromAppData), fromJS(toAppData)];

      const fromVariablePart: VariablePart = {
        outcome: encodeOutcome(outcome),
        appData: fromAppDataBytes
      };
      const toVariablePart: VariablePart = {
        outcome: encodeOutcome(outcome),
        appData: toAppDataBytes
      };

      await expectRevert(
        () =>
          AttestationApp.validTransition(
            fromVariablePart,
            toVariablePart,
            turnNum,
            numParticipants
          ),
        errorMsg
      );
    }
  );
});
